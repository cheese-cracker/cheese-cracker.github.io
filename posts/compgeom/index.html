<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.124.1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content=ZgotmplZ><meta name=description content="Simple Notes for Computational Geometry"><meta name=author content=cheese-cracker><meta name=copyright content=cheese-cracker><meta http-equiv=content-language content="zh,en"><link rel=canonical href=https://cheese-cracker.github.io/posts/compgeom/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Computational Geometry&nbsp;&ndash;&nbsp;Futuristic ideas</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin>
<link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.f10698d6b0c9ee48da25e4e5930889925ad8ad73fa28b9b0939203ed47485de92982853fedfa8047a181dcac37412c04.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/css/core.min.f10698d6b0c9ee48da25e4e5930889925ad8ad73fa28b9b0939203ed47485de92982853fedfa8047a181dcac37412c04.css integrity=sha384-8QaY1rDJ7kjaJeTlkwiJklrYrXP6KLmwk5ID7UdIXekpgoU/7fqAR6GB3Kw3QSwE></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:18px;font-weight:400;line-height:2;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html{background:#fff;--site-name-color:#3f4b67;--color-primary:#005ab4;--link-underline:#90cff9;--blockquote-border-left:6px solid #0051a2;--block-background-color:#d7daff;--pag-background-color:rgba(0, 122, 255, 0.5);--box-shadow:1px 1px 2px rgba(0, 0, 0, 0.125);--title-color:#303033;--body-color:#444}html[data-theme=dark]{background:#22272e;--site-name-color:#539bf5;--color-primary:#99bde1;--link-underline:#0051a2;--blockquote-border-left:6px solid #5176bf;--block-background-color:#002c58;--box-shadow:none;--title-color:#dadada;--body-color:#e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1;margin-block-start:0;margin-block-end:0}h1{font-size:28px}h2{font-size:26px}h3{font-size:24px}h4{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.2rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(80ch,calc(100% - 64px))2fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0 0;background-image:url(/img/covercrop.png);display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:72px 25px;border:4px solid #000;justify-content:space-between;align-items:baseline}.header-left{background-color:var(--block-background-color);padding:10px;border:2px solid #000}.header-right{background-color:var(--block-background-color);padding:10px 15px;border:2px solid #000}.site-name{display:inline-block;font-weight:600;font-size:24px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:20px;padding:4px 6px;margin:2px 3px 2px 0;line-height:2;white-space:nowrap;border:1px solid var(--body-color);border-radius:4px}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px;padding:5px;border:1px solid var(--body-color)}.note-title{font-size:22px;font-weight:700}.note-date,.note-content{font-size:16px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:18px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.article-navigation p{color:var(--body-color);border:2px solid var(--body-color);padding:4px}.footer{font-size:16px;margin:40px 0 20px;border:1px solid var(--body-color)}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:22px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:18px;margin-top:20px;color:#838387}.lastmod-date{font-size:18px;color:#838387}.markdown-body{font-size:18px;color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}@font-face{font-family:averia sans libre;font-style:italic;font-weight:300;font-display:swap;src:local('Averia Sans Libre Light Italic'),local('AveriaSansLibre-LightItalic'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6caxZG_G5OvCf_rt7FH3B6BHLMEdVLKisSH5DdLw.ttf)format('truetype')}@font-face{font-family:averia sans libre;font-style:italic;font-weight:400;font-display:swap;src:local('Averia Sans Libre Italic'),local('AveriaSansLibre-Italic'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6RaxZG_G5OvCf_rt7FH3B6BHLMEdVLIoAwDw.ttf)format('truetype')}@font-face{font-family:averia sans libre;font-style:italic;font-weight:700;font-display:swap;src:local('Averia Sans Libre Bold Italic'),local('AveriaSansLibre-BoldItalic'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6caxZG_G5OvCf_rt7FH3B6BHLMEdVLKjsVH5DdLw.ttf)format('truetype')}@font-face{font-family:averia sans libre;font-style:normal;font-weight:300;font-display:swap;src:local('Averia Sans Libre Light'),local('AveriaSansLibre-Light'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6SaxZG_G5OvCf_rt7FH3B6BHLMEd3lMJcXL5c.ttf)format('truetype')}@font-face{font-family:averia sans libre;font-style:normal;font-weight:400;font-display:swap;src:local('Averia Sans Libre Regular'),local('AveriaSansLibre-Regular'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6XaxZG_G5OvCf_rt7FH3B6BHLMEdVOEoc.ttf)format('truetype')}@font-face{font-family:averia sans libre;font-style:normal;font-weight:700;font-display:swap;src:local('Averia Sans Libre Bold'),local('AveriaSansLibre-Bold'),url(https://fonts.gstatic.com/s/averiasanslibre/v8/ga6SaxZG_G5OvCf_rt7FH3B6BHLMEd31N5cXL5c.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:italic;font-weight:400;font-display:swap;src:local('Source Code Pro Italic'),local('SourceCodePro-It'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_QiYsKILxRpg3hIP6sJ7fM7PqlONvUlMc.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:italic;font-weight:500;font-display:swap;src:local('Source Code Pro Medium Italic'),local('SourceCodePro-MediumIt'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_ViYsKILxRpg3hIP6sJ7fM7PqlONMnt9co5mg.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:italic;font-weight:600;font-display:swap;src:local('Source Code Pro SemiBold Italic'),local('SourceCodePro-SemiBoldIt'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_ViYsKILxRpg3hIP6sJ7fM7PqlONMLsNco5mg.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:italic;font-weight:700;font-display:swap;src:local('Source Code Pro Bold Italic'),local('SourceCodePro-BoldIt'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_ViYsKILxRpg3hIP6sJ7fM7PqlONNvsdco5mg.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:normal;font-weight:400;font-display:swap;src:local('Source Code Pro Regular'),local('SourceCodePro-Regular'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevT.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:normal;font-weight:500;font-display:swap;src:local('Source Code Pro Medium'),local('SourceCodePro-Medium'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_XiYsKILxRpg3hIP6sJ7fM7PqtzsjDs-cv.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:normal;font-weight:600;font-display:swap;src:local('Source Code Pro SemiBold'),local('SourceCodePro-SemiBold'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_XiYsKILxRpg3hIP6sJ7fM7Pqt4s_Ds-cv.ttf)format('truetype')}@font-face{font-family:source code pro;font-style:normal;font-weight:700;font-display:swap;src:local('Source Code Pro Bold'),local('SourceCodePro-Bold'),url(https://fonts.gstatic.com/s/sourcecodepro/v11/HI_XiYsKILxRpg3hIP6sJ7fM7Pqths7Ds-cv.ttf)format('truetype')}html{font-family:averia sans libre,-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,SimHei,segoe ui,Roboto,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol}code,pre,tt,kbd,samp{font-family:source code pro,Menlo,Consolas,liberation mono,monospace;font-weight:500}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-VK520LPFV1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-VK520LPFV1")</script></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><p class=site-name>Futuristic ideas</p></a></div><div class=header-right><div class=nav><a class=nav-item href=/>Home</a><a class=nav-item href=/tags/>Tags</a><a class=nav-item href=/archives/>Archives</a><a class=nav-item href=/search/>Search</a><a class=nav-item href=/about/>About</a><script>const htmlEl=document.getElementsByTagName("html")[0],currentTheme=localStorage.getItem("theme")?localStorage.getItem("theme"):null;currentTheme&&(htmlEl.dataset.theme=currentTheme);const toggleTheme=e=>{htmlEl.dataset.theme=e,localStorage.setItem("theme",e)};localStorage.getItem("theme")==="dark"||window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?htmlEl.dataset.theme="dark":toggleTheme("light")</script>
<button class="data-theme-btn dark-hidden" onclick='toggleTheme("dark")'>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#3f4b67" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10A9 9 0 1110 3 7 7 0 0021 10z"/></svg>
</button>
<button class="data-theme-btn light-hidden" onclick='toggleTheme("light")'><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#e9e9e9" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4 4l1 1m10 10 1 1M1 12h2m18 0h2M4 20l1-1M20 6l1-1"/></svg></button></div></div></section><section id=content><div class=article-containter><section class=article-header><h1>Computational Geometry</h1><p class=article-date>2020-10-01</p></section><section class=article-labels><a class="article-tag li" href=/tags/cs/><span class=hashtag>#</span>cs</a><a class="article-tag li" href=/tags/math/><span class=hashtag>#</span>math</a><a class="article-tag li" href=/tags/c++/><span class=hashtag>#</span>c++</a><a class="article-tag li" href=/tags/graphs/><span class=hashtag>#</span>graphs</a></section><article class=markdown-body><h2 id=key-resources>Key Resources</h2><ol><li>Textbook: Computational Geometry - Algorithms and Applications</li><li><a href=https://www.coursera.org/learn/computational-geometry target=_blank rel=noopener>Coursera Course</a>: For the Problemset and Implementations (Till Part 5)</li><li><a href="https://www.youtube.com/channel/UCuAzKw_VngkAsQh7ummYq0A/playlists?view=50&amp;shelf_id=1" target=_blank rel=noopener>Philipp Kindermann</a>&rsquo;s Lectures Series (Part 6 and Onwards)</li><li>Various Random Resources found on the internet!<ul><li><a href=https://geomalgorithms.com/ target=_blank rel=noopener>Geom Algorithms</a></li><li><a href=https://cp-algorithms.com/ target=_blank rel=noopener>CP Algorithms</a></li></ul></li></ol><h4 id=further-reading--interesting-resources>Further Reading / Interesting Resources</h4><ul><li><a href="https://observablehq.com/@mbostock/to-infinity-and-back-again?collection=@observablehq/algorithms" target=_blank rel=noopener>ObservableHQ - Infinity and Back Again</a>: Voronoi Diagrams for Infinite Polygons</li><li>Book: Foundations of Multidimensional and Metric Data Structures - Hanen Samet (2006)</li><li><a href="https://www.youtube.com/playlist?list=PL8FaHk7qbOD4F7nPFfgD0dGdLos1uhUPg" target=_blank rel=noopener>Josh Hug&rsquo;s Lectures on Multidimensional Data</a>: Good intuition on k-d trees and quad trees.</li><li><a href=https://www.wias-berlin.de/software/tetgen/features.html target=_blank rel=noopener>TestGen</a>: Voronoi Diagrams and Delaunay Tetrahedralizations for 3D Points. Software</li><li><a href=https://flylib.com/books/en/2.587.1.38/1/ target=_blank rel=noopener>Generalization of Voronoi Diagrams</a>: Originally from a book on (Geometric Data Structures for Computer Graphics, 2005)</li></ul><h2 id=overview>Overview</h2><p>To learn computational geometry, these are the steps/resources I used,</p><ol><li>Week 1 - Week 5: Coursera - Computational Geometry<ul><li>For theory, read from book and/or random resources off the internet. Philipp&rsquo;s lectures are also available for this.</li><li>Focus on the problemset for the course.</li><li>Recommended Prerequisite: Good understanding and practice of DSA. Some of the problems have tons of edge cases!</li></ul></li><li>Week 6 - Week 10: Philipp Kindermann&rsquo;s Lecture Series<ul><li>This part is more theory oriented and covers Voronoi Diagrams, Delaunay Triangulations too.</li><li>Again some parts can be followed up from the book as well.</li><li>Recommended Prerequisite: Basic graph theory (maximal planar graph, duals), basic DSA (analyzing time complexity)</li></ul></li></ol><h5 id=general-implementation-aspects>General Implementation Aspects</h5><ul><li>Use slope pairs</li><li>Triangle orientation check (sign of area)</li><li>Sum of area of triangles to form interior</li><li>Ray out of a point inside intersects polygon odd times</li><li>Check line segment intersections by checking orientation of each of the four points (not two!)</li><li>It also helps to plot sample testcases for debugging</li><li>Modulo to cyclicly iterate through points of a Polygon</li><li>Carefully inspect, input/output format as well as edge cases</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// My Header - (Used mostly STL instead of OOP)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>#define ll long long
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#define x first
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#define y second
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span><span style=color:#ff79c6>typedef</span> pair<span style=color:#ff79c6>&lt;</span>ll,ll<span style=color:#ff79c6>&gt;</span> vertex;
</span></span><span style=display:flex><span><span style=color:#ff79c6>typedef</span> pair<span style=color:#ff79c6>&lt;</span>ll,ll<span style=color:#ff79c6>&gt;</span> point;
</span></span><span style=display:flex><span><span style=color:#ff79c6>typedef</span> pair<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>double</span>, <span style=color:#8be9fd>double</span><span style=color:#ff79c6>&gt;</span> ppoint;
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> ppoint INF_POINT <span style=color:#ff79c6>=</span> {<span style=color:#bd93f9>2e9</span>, <span style=color:#bd93f9>2e9</span>};
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> <span style=color:#8be9fd>double</span> EPS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1e-16</span>;
</span></span></code></pre></div><h2 id=week-1>Week 1</h2><p>1. Point and Vector (Triangle Sign Check)</p><p>This will be used in most future problems as well. The most generalized template is below. Note that <code>area</code> is actually twice the actual area.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>trisign</span>(ppoint a, ppoint b, ppoint pt){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>double</span> area <span style=color:#ff79c6>=</span> a.x <span style=color:#ff79c6>*</span> b.y <span style=color:#ff79c6>+</span> b.x <span style=color:#ff79c6>*</span> pt.y <span style=color:#ff79c6>+</span> pt.x <span style=color:#ff79c6>*</span> a.y <span style=color:#ff79c6>-</span> a.y <span style=color:#ff79c6>*</span> b.x <span style=color:#ff79c6>-</span> b.y <span style=color:#ff79c6>*</span> pt.x <span style=color:#ff79c6>-</span> pt.y <span style=color:#ff79c6>*</span> a.x;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(area <span style=color:#ff79c6>&gt;</span> EPS){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    }<span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(area <span style=color:#ff79c6>&lt;</span> <span style=color:#ff79c6>-</span>EPS){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2. Point in Triangle</p><p>Principle is the sum of the 3 individual triangles (2 vertices, 1 point) would be equal to total area (3 vertices).</p><p>3. Point in Polygon</p><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/point_in_polygon_ray.jpg><img loading=lazy src=/plots/compgeom/point_in_polygon_ray.jpg width=auto height=auto alt="Point in Polygon with ray from infinity"></a></p><ul><li>Take ray from point to infinity</li><li>Check intersection with each line segment O(N)</li><li>Parity of the number of intersection determine inside(odd) or outside(even)</li><li>Ignore if line segment coincides with the ray.</li></ul><p>This is used again in future problems like 4-1/4-2.
Draw a ray from <code>P</code> to <code>INF_POINT</code>. Check the if the no. of intersections are odd or even.
Make sure an endpoint is not counted twice - that&rsquo;s why <strong>semi-open interval</strong> is checked (<code>semi_check_intersect</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>bool</span> <span style=color:#50fa7b>inbetween</span>(ppoint a, ppoint midd, ppoint b){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>double</span> minx <span style=color:#ff79c6>=</span> min(a.x, b.x);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>double</span> miny <span style=color:#ff79c6>=</span> min(a.y, b.y);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>double</span> maxx <span style=color:#ff79c6>=</span> max(a.x, b.x);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>double</span> maxy <span style=color:#ff79c6>=</span> max(a.y, b.y);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> (minx <span style=color:#ff79c6>&lt;=</span> midd.x <span style=color:#ff79c6>&amp;&amp;</span> midd.x <span style=color:#ff79c6>&lt;=</span> maxx) <span style=color:#ff79c6>&amp;&amp;</span> (miny <span style=color:#ff79c6>&lt;=</span> midd.y <span style=color:#ff79c6>&amp;&amp;</span> midd.y <span style=color:#ff79c6>&lt;=</span> maxy);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Only check semi-interval [s1, s2) intersection [d1, d2]
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>bool</span> <span style=color:#50fa7b>semi_check_intersect</span>(ppoint d1, ppoint d2, ppoint s1, ppoint s2){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> s1_side <span style=color:#ff79c6>=</span> trisign(d1, d2, s1);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> s2_side <span style=color:#ff79c6>=</span> trisign(d1, d2, s2);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> d1_side <span style=color:#ff79c6>=</span> trisign(s1, s2, d1);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> d2_side <span style=color:#ff79c6>=</span> trisign(s1, s2, d2);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(s1_side<span style=color:#ff79c6>*</span>s2_side <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> d1_side<span style=color:#ff79c6>*</span>d2_side <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span>){
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// If segment lies completely inside we can ignore it; So check if strictly only s1 is present
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> (inbetween(d1, s1, d2) <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>inbetween(d1, s2, d2));
</span></span><span style=display:flex><span>    }<span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(s1_side<span style=color:#ff79c6>*</span>s2_side <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> d1_side <span style=color:#ff79c6>*</span> d2_side <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span>){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>bool</span> <span style=color:#50fa7b>point_in_polygon</span>(vector<span style=color:#ff79c6>&lt;</span>vertex<span style=color:#ff79c6>&gt;&amp;</span> poly, pair<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>double</span>, <span style=color:#8be9fd>double</span><span style=color:#ff79c6>&gt;</span> p){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ray_intersects <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>int</span>)poly.size();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; k <span style=color:#ff79c6>&lt;</span> n; <span style=color:#ff79c6>++</span>k){
</span></span><span style=display:flex><span>        ray_intersects <span style=color:#ff79c6>+=</span> semi_check_intersect(p, INF_POINT, poly[k], poly[(k<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>%</span> n]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(ray_intersects <span style=color:#ff79c6>%</span> <span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    }<span style=color:#ff79c6>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>4. Points in Convex Polygon</p><p>The steps I used were as follows -</p><ul><li>Get Centroid: Choose 3 non-colinear points (<code>trisign</code>)</li><li>Sort by Angle: Array of pairs <code>slope_pairs</code> which stores <code>{atan2(points[i].y - centroid.y, points[i].x - centroid.x), i}</code> and then sort.</li><li>Binary Search by Angle (Helper Function): <code>pair&lt;ll, ll> binsearch_angle(vector&lt;pair&lt;double,ll>>& angle_pair, double angle_val)</code> gives the pair of indices of the two vertices.</li><li>Check in triangle: Use the previous part to check if point in the triangle given by <code>binsearch_angle</code></li></ul><h2 id=week-2>Week 2</h2><ul><li><p>Convex Hull Algorithms</p><ul><li><p>Graham Scan</p><ol><li>Initialize a pair of points in S</li><li>Add new point</li><li>Check if orientation of (n-2)nd point with ((n-3)rd, nth) point is left(ccw)/right(cw) (and 0)</li><li>Else pop the 2nd last point</li></ol></li><li><p>Andrew&rsquo;s (Preferred - NlogN for sort)</p><ol><li>Take line (leftmost or minx) point & (rightmost or maxx) point</li><li>Sort Points in x-coords</li><li>Partition all other points (by orientation) into Lower or Upper according to below/above the partition line. (stable or resort)</li><li>Run Graham Scan and pop 2nd last element if right(for Upper Partition) or left(for Lower Partition)</li></ol></li></ul><p>Points to Note: - Andrew&rsquo;s Scan can also be thought similar to a sweep line - At every event point(p) check orientation of last point in S(n) wrt to S(n-1) and p - Convex Hull can also be used for other polygons (see Unit Circle&rsquo;s questions)</p><ul><li>Jarvis March<ol><li>Take lowest point in H</li><li>Take 2nd point with smallest polar angle in H</li><li>Take last (n-1) and (n-2) points as line</li><li>Find smallest polar angle point wrt. this line</li><li>Repeat till 1st point is found</li></ol></li></ul></li></ul><p>1. Convex Polygon Check</p><p>Check if polygon is convex. Stable Partition points to upper part and lower part (like Modified Graham&rsquo;s).
Check (<code>convex_check</code>) if all Up points have no lefts. Check again if all Down points have no rights.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>bool</span> <span style=color:#50fa7b>convex_check</span>(vector<span style=color:#ff79c6>&lt;</span>pair<span style=color:#ff79c6>&lt;</span>ll,ll<span style=color:#ff79c6>&gt;&gt;&amp;</span> points, <span style=color:#8be9fd>int</span> invsign){
</span></span><span style=display:flex><span>    ll sz <span style=color:#ff79c6>=</span> points.size();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> sz<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>; <span style=color:#ff79c6>++</span>i){
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// NO Left(&gt;0) if Down, NO Right(&lt;0) if Up
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span>(trisign(points[i], points[i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>2</span>], points[i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>==</span> invsign){
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>invsign</code> is an integer which is 1 or -1, depending on lower or upper hull.</p><p>2. Convex Hull</p><ul><li>Convex hull follows similar to the convex hull check.</li><li>For each vertex, we check <code>while(hull_size + 1 >= 3)</code></li><li>If <code>trisign(hull[hull_size - 2], points[i], hull[hull_size -1])</code> matches our <code>invsign</code> then pop the 2nd last vertex, Or else break out of the <code>while</code> loop to check the next vertex.</li><li>Function Header: <code>void construct_convex_hull(vector&lt;pair&lt;ll,ll>>& points, vector&lt;pair&lt;ll,ll>>& hull, int invsign);</code></li><li>After <code>construct_convex_hull</code> for both partitions, we zip the upper and lower Hulls. Thus forming the CCW convex hull.</li></ul><p>3. Tangents to Polygon</p><p>See <a href=http://www.geomalgorithms.com/a15-_tangents.html target=_blank rel=noopener>geomalgorithms.com</a> for excellent explaination of technique.
As stated, we need sign(left point) != sign(right point) for tangent
In our case to find left and right tangents, we can put a condition like this, inside our loop iterating through each point.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>int</span> signl <span style=color:#ff79c6>=</span> trisign(left_pt, points[i], pt);
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> signr <span style=color:#ff79c6>=</span> trisign(points[i], right_pt, pt);
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span>(signl <span style=color:#ff79c6>!=</span> signr){
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// CCW =&gt; pt lies L/R wrt. leftpt
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span>(signl <span style=color:#ff79c6>==</span> sign <span style=color:#ff79c6>||</span> signr <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>-</span>sign){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> points[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where <code>sign</code> is given by whether we want left or right tangent.</p><p>4. Union of Convex Hulls</p><p>Take any point Z inside Convex Polygon A. If Z is also inside B, sort the points by angle and apply graham scan. If Z is not inside B, remove inner chain and apply Graham&rsquo;s Scan on outer chain.
OR
Just apply Graham&rsquo;s Scan to all the points since both algorithms have worst case, NlogN.
This may however be slightly less optimal. (But it works :-))</p><h2 id=week-3>Week 3</h2><p>1. 2 Line Segment Intersections</p><p>See <a href=https://cp-algorithms.com/geometry/check-segments-intersection.html target=_blank rel=noopener>CP Algorithms</a> for technique.
Helper functions for this include, <code>trisign</code>, <code>inbetween</code>, <code>determinant</code> are used.
Remember to check for &lsquo;No Common Points&rsquo; for both determinant = 0 and not. Watch out for corner cases. (Tons of them!)</p><p>2. Polygon Intersection</p><p>Either Clipping (Sutherland Hodgman) or Line Sweep (Shamos-Hoey) could be used. For clipping, see <a href=https://www.geeksforgeeks.org/polygon-clipping-sutherland-hodgman-algorithm-please-change-bmp-images-jpeg-png/ target=_blank rel=noopener>G4G</a>.
The Algorithms are as follows,</p><ul><li><p>Sutherland-Hodgman</p><ul><li>First choose a polygon</li><li>Cut out 2nd polygon from first (check orientation at each line and split half-plane)</li><li>Go through the vertices of the 2nd polygon and check if next vertices crosses the line or not. ~O(NM) time</li><li>Also, for convex + non-convex</li></ul></li><li><p>Shamos-Hoey (Sweep-Line Like) - (N + M) vertical lines from vertices - Obtain inner fragment at each line (inner up and inner down) - 4 lists of vertices (upper, lower) - Only for convex + convex</p><pre><code>Within the same TC but slightly less optimal, a simpler approach using all the previous functions can be used.
</code></pre><p>Simply, find all line segment intersections and check point in polygon for each vertex.
Then just order points cw / ccw by sorting by angle from centroid.
See <a href="https://observablehq.com/@mbostock/sutherland-hodgman-clipping?collection=@observablehq/algorithms" target=_blank rel=noopener>D3 Mike&rsquo;s ObservableHQ</a> for an awesome visualization.</p></li></ul><p>3. Intersection of Horizontal and Vertical Segments</p><p>This is briefly discussed in &lsquo;Competitive Programming Handbook by Antti&rsquo;.
Scan the the edges and classify and store as horizontal/vertical segments.
Store in <code>start</code>, tuples of the form</p><ul><li><code>{x1, 2, vptr}</code> for vertical segments</li><li><code>{xmin, 1, hptr}</code> and <code>{xmax, 3, hptr}</code> for horizontal segments
The operations are 1(Add eventpt), 2(Intersect with vertical), 3(Remove Endpoint).
Sort the <code>start</code> array, and perform a line sweep over it.
Use order-statistic tree (policy-based ds) for the <code>status</code>. (or implement similar RBT using nodes)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// Horizontal Segment (height)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>ll<span style=color:#ff79c6>&gt;</span> hzlevel;
</span></span><span style=display:flex><span><span style=color:#6272a4>// Vertical Segment (height, range)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>pair<span style=color:#ff79c6>&lt;</span>ll,ll<span style=color:#ff79c6>&gt;&gt;</span> vlevel;
</span></span><span style=display:flex><span><span style=color:#6272a4>// Starting Point Tuples (xcoord, operation, index)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>vector<span style=color:#ff79c6>&lt;</span>ll<span style=color:#ff79c6>&gt;&gt;</span> start;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// In operation 2 we check intersects like this,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>lo <span style=color:#ff79c6>=</span> status.order_of_key(vlevel[ix].first);
</span></span><span style=display:flex><span>hi <span style=color:#ff79c6>=</span> status.order_of_key(vlevel[ix].second<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>intersects <span style=color:#ff79c6>+=</span> hi <span style=color:#ff79c6>-</span> lo;
</span></span></code></pre></div><p>4. Intersection of Set of Segments</p><ul><li><p>Classic Sweep Line for Segment Intersections</p><ul><li><p>Consists (key vars)</p><ul><li>Event Point<ul><li>Upper (or left) Endpoint of Segment is p (U(p))</li><li>Lower Endpoint of Segment is p (L(p))</li><li>Intersection/Internal Point of segment is p (C(p))</li></ul></li><li>(Q) Event Queue of found event points</li><li>(S) Set of of all Segements (Array)</li><li>(T) Set of Status (RB Tree?)</li><li>Event Queue set to check if already present?</li></ul></li><li><p>FindIntersection(S)</p><ul><li>Initialize Q and T</li><li>Push first U( p ) endpoint (and corresponding line segment/index) in Q</li><li>While Q non-empty, HandleEventPoint</li></ul></li><li><p>HandleEventPoint(p)</p><ul><li>Consists of U, L, C</li><li>Generate L( p ) and C( p ) from adjacent segments in T</li><li>Segments of $L(p) \cup U(p) \cup C(p) \geq 2$<ul><li>Report intersection p</li></ul></li><li>Delete L( p ) since segment ends</li><li>Delete C( p ) to swap (2nd priority to U)</li><li>Insert U( p )</li><li>Insert Back C( p ) (finish swap)</li><li>If there is no U( p ) and no C( p )<ul><li>FindEventPoints(sl, sr, p) where sl, sr are the adjacent segments of p in T</li></ul></li><li>Else<ul><li>Take leftmost segment of U( p ) union C( p ), ie (topmost priority) as sl</li><li>Take left neighbour of sl in T, s1</li><li>FindEventPoints(sl, s1, p) // top Segments intersections</li><li>Take rightmost segment of $U(p) \cap C(p)$, ie (least priority) as sr</li><li>Take right neighbour of sr in T, s2</li><li>FindEventPoints(sr, s2, p) // bottom Segments intersections</li></ul></li></ul></li></ul></li><li><p>Key Features for any Sweep Line</p><ul><li>Event Point (often coordinate-compressed)</li><li>Status Set containing elements important for current event point</li><li>Line sweeps across some direction (Obvious!)</li></ul></li></ul><p>Unfortunately, I wasn&rsquo;t able to code this one up. However, <a href=https://geomalgorithms.com/a09-_intersect-3.html target=_blank rel=noopener>geom algorithms</a> explains with code the approach to doing this.</p><h2 id=week-4>Week 4</h2><p>1. Diagonals of any Simple Polygon</p><p>For diagonals, one technique is to first check if diagonal intersects with any other polygon line segment.
Then check if Point-in-Polygon for the midpoint, to know if it is inside/outside.
So, <code>trisign</code>, <code>inbetween</code>, <code>semi_check_intersect</code>, <code>check_intersect</code> and <code>point_in_polygon</code> are needed.
Note that <code>check_intersect</code> includes endpoints unlike <code>semi_check_intersect</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>intersect <span style=color:#50fa7b>diagonal_check</span>(vector<span style=color:#ff79c6>&lt;</span>vertex<span style=color:#ff79c6>&gt;&amp;</span> poly, ll i, ll j){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>int</span>)poly.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Check Intersections
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> k <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; k <span style=color:#ff79c6>&lt;</span> n; <span style=color:#ff79c6>++</span>k){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(k <span style=color:#ff79c6>==</span> i <span style=color:#ff79c6>||</span> k <span style=color:#ff79c6>==</span> j <span style=color:#ff79c6>||</span> (k<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>%</span> n <span style=color:#ff79c6>==</span> i <span style=color:#ff79c6>||</span> (k<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>%</span> n <span style=color:#ff79c6>==</span> j) <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> res <span style=color:#ff79c6>=</span> check_intersect(poly[i], poly[j], poly[k], poly[(k<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>%</span>n]);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(res <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>return</span> crossing;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Check if Midpoint in polygon. Assumption: diagonal does not intersect
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    pair<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>double</span>, <span style=color:#8be9fd>double</span><span style=color:#ff79c6>&gt;</span> midd <span style=color:#ff79c6>=</span> {(poly[i].x <span style=color:#ff79c6>+</span> poly[j].x)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>2.0</span>, (poly[i].y <span style=color:#ff79c6>+</span> poly[j].y)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>2.0</span>};
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(point_in_polygon(poly, midd)){
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> inner;
</span></span><span style=display:flex><span>    }<span style=color:#ff79c6>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> outer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2. Ear-Cutting Algorithm for Triangulation of Convex Polygons</p><p>Steps -</p><ol><li>Preprocess: If for every vertex, adjacent vertices form inner diagonal. Mark as Ear. ~O($N^2$ for diagonal_check)</li><li>Start processing ears in-order from a starting vertex (Try to maintain order in which they are checked)</li><li>Delete Current Ear Vertex from the polygon (& is_ear) vector. Insert (diagonal with adjacent verts and the pt) as a triangle.</li><li>Check if vleft, vright is a ear (~O(N))</li><li>Stop when ear-list is empty or polygon has less than 3 vertices (all vertices are done!)</li></ol><p>Time: $O(N^3)$ (Sum of $N^2$ operations)</p><p>After preprocessing the ears in the <code>is_ear</code> array, the algorithm proceeds as follows,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// Set start point
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> st <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span>(n <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>3</span>){
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Start loop at previous triangle endpoint
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> st; j <span style=color:#ff79c6>&lt;</span> st <span style=color:#ff79c6>+</span> n; <span style=color:#ff79c6>++</span>j){
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> j <span style=color:#ff79c6>%</span> n;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(is_ear[i]){
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Find First Ear and Delete
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            vector<span style=color:#ff79c6>&lt;</span>vertex<span style=color:#ff79c6>&gt;</span> res_triangle <span style=color:#ff79c6>=</span> { poly[(i <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>+</span> n) <span style=color:#ff79c6>%</span> n], poly[i], poly[(i <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>%</span> n] };
</span></span><span style=display:flex><span>            triangles.pb(res_triangle);
</span></span><span style=display:flex><span>            is_ear.erase(is_ear.begin() <span style=color:#ff79c6>+</span> i);
</span></span><span style=display:flex><span>            poly.erase(poly.begin() <span style=color:#ff79c6>+</span> i);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Update Polygon and check ears
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            n <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>int</span>)poly.size();
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Lower Vertex
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            is_ear[(i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> <span style=color:#ff79c6>+</span> n) <span style=color:#ff79c6>%</span> n] <span style=color:#ff79c6>=</span> check_ear(poly, (i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> <span style=color:#ff79c6>+</span> n) <span style=color:#ff79c6>%</span> n);
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Upper Vertex (new index -&gt; i % n)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            is_ear[i <span style=color:#ff79c6>%</span> n] <span style=color:#ff79c6>=</span> check_ear(poly, i <span style=color:#ff79c6>%</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Set start of next iteration
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            st <span style=color:#ff79c6>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, add remaining polygon into <code>triangles</code>.
The <code>check_ear</code> functions checks <code>diagonal_check</code>(from 4-1) on the neighbouring vertices.
It also helps to plot testcases like this,</p><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/4-2testcase.png><img loading=lazy src=/plots/compgeom/4-2testcase.png width=auto height=auto alt="Testcase for Polygon triangulations"></a></p><p>3. Monotone Polygon Triangulation</p><p>Triangulation of strictly y-monotone polygons. See <a href=http://homepages.math.uic.edu/~jan/mcs481/triangulating.pdf target=_blank rel=noopener>MCS481 Slides</a> for a pretty good psuedocode or the Book is also great.
For Diagonal check part, time complexity would be high therefore it is better to use Concavity Check with <code>trisign</code> instead. Remember to add diagonals from last (lowermost) vertex also. <code>sidemap</code> is used to store Left/Right and <code>vertex</code> is the merged sorted vertex list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>triangulate_monotone</span>(vector<span style=color:#ff79c6>&lt;</span>point<span style=color:#ff79c6>&gt;&amp;</span> verts, map<span style=color:#ff79c6>&lt;</span>point, <span style=color:#8be9fd>bool</span><span style=color:#ff79c6>&gt;</span> sidemap, vector<span style=color:#ff79c6>&lt;</span>polygon<span style=color:#ff79c6>&gt;&amp;</span> diags){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> sz <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>int</span>)verts.size();
</span></span><span style=display:flex><span>    deque<span style=color:#ff79c6>&lt;</span>point<span style=color:#ff79c6>&gt;</span> rack <span style=color:#ff79c6>=</span> {verts[<span style=color:#bd93f9>0</span>], verts[<span style=color:#bd93f9>1</span>]};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>; j <span style=color:#ff79c6>&lt;</span> sz<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>; <span style=color:#ff79c6>++</span>j){
</span></span><span style=display:flex><span>        point vlast <span style=color:#ff79c6>=</span> rack.back();
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Process Vertex
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span>(sidemap[verts[j]] <span style=color:#ff79c6>!=</span> sidemap[rack.back()]){
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Opposite Sides
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>while</span>((<span style=color:#8be9fd>int</span>)rack.size() <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>1</span>){
</span></span><span style=display:flex><span>                diags.pb(vector<span style=color:#ff79c6>&lt;</span>point<span style=color:#ff79c6>&gt;</span>{rack.back(), verts[j]});
</span></span><span style=display:flex><span>                rack.pop_back();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            rack.pop_back();
</span></span><span style=display:flex><span>            rack.push_back(vlast);
</span></span><span style=display:flex><span>        }<span style=color:#ff79c6>else</span>{
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Same Side
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            rack.pop_back();
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// rack.back() should be inward wrt. vlast and verts[j] -&gt; i.e, match sign of side of vlast
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>while</span>(rack.size() <span style=color:#ff79c6>&amp;&amp;</span> check_concave(vlast, rack.back(), verts[j], sidemap[verts[j]])){
</span></span><span style=display:flex><span>                diags.pb({verts[j], rack.back()});
</span></span><span style=display:flex><span>                vlast <span style=color:#ff79c6>=</span> rack.back();
</span></span><span style=display:flex><span>                rack.pop_back();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            rack.push_back(vlast);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        rack.push_back(verts[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Add diags from all verts in stack (except top and bottom) to lowermost vertex
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    rack.pop_front();
</span></span><span style=display:flex><span>    rack.pop_back();
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span>(<span style=color:#ff79c6>auto</span> <span style=color:#8be9fd;font-style:italic>v</span>: rack){
</span></span><span style=display:flex><span>        diags.push_back(vector<span style=color:#ff79c6>&lt;</span>point<span style=color:#ff79c6>&gt;</span>{verts[sz<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>], v});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>4. Number of Triangulations of a Convex Polygon</p><ul><li>From the <a href=https://en.wikipedia.org/wiki/Catalan_number target=_blank rel=noopener>wikipedia page</a>, A convex polygon with n + 2 sides can be triangulated to n triangles by non-crossing lines.</li><li>Number of different ways of triangulation is Catalan Nos.</li><li>For any triangulation, there would be exactly 2 vertices that don&rsquo;t need to be joined by a diagonal.(or whose degrees stay the same!) So, catalan nos. is on the $n-2$ vertices connected by diagonals.</li><li>The $\sum c_i c_{n-i}$ Form: Recurrence relation is the breaking of the polygons by one of the diagonals.</li></ul><h2 id=week-5>Week 5</h2><ul><li><p>k-D Trees</p><ul><li>Base Structure: BST</li><li>Stores values like BST, but instead of ordering only by value like BST, it needs to order by <code>k</code> params.</li><li>This is done by selecting a splitting criteria, like for 2D: alternate between &lsquo;X&rsquo; and &lsquo;Y&rsquo; parameters based on whether the depth is even/odd.</li></ul></li><li><p>2D Layered Range Trees</p><ul><li>Base Structure: Red-Black Tree or balanced BST</li><li>See <a href=https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t target=_blank rel=noopener>differences between some well-known trees</a>.</li><li>2D Layered Range tree stores points in its associated array, and optimized for &ldquo;which points fall within a given interval&rdquo; queries.</li><li>The assoc array of point <code>v</code> is the two-pointer zip (merge-sort) of <code>2v</code> and <code>2v+1</code> vertices.</li><li>It can be represented similar to 2D segment tree, but value contains &ldquo;the points themselves&rdquo;. (segtree consists of sum of no. of points)</li><li>Both 2D layering range tree and segment trees can be used interchangeably.</li><li>Fractional Cascading is technique to store binary_searched index of the element as pointer. So $O(logN)$ extra factor isn&rsquo;t needed. Each element of assoc array of point <code>v</code> also contains pointers to <code>2v</code> and <code>2v+1</code> nodes arrays&rsquo; binary_searched(lower_bound) index.</li></ul></li><li><p>2D Priority Search Tree</p><ul><li>Base Structure: Binary Heap or Priority Queue (Scaled up to 2D).</li><li>Shows one-sided unbounded range of values.</li></ul></li></ul><p>1. Closest Point</p><p>Simple binary-search implementation as points have only 1 parameter.</p><p>2. Number of Points in Rectangle</p><p>The easiest implementation in via a Cartesian Tree. (similar to Kdtree)
My code is a 2D Segment Tree however I <strong>recommend</strong> using an OOP approach with <strong>Cartesian Tree</strong> instead!</p><p>This is was approximate workflow while designing 2D Segment Tree. See <a href=https://cp-algorithms.com/data_structures/segment_tree.html target=_blank rel=noopener>CP Algorithms</a>&rsquo;s
compression of 2D segment tree for ideas. Fractional Cascading for speeding up!</p><p>Below are the design notes for the code.</p><hr><pre tabindex=0><code>General Design -
  - buildx, buildy, queryx, queryy
  - Range compression (See cp-algorithms.com tips)
  - NlogN memory and (logN)^2 time per query
Construction -
  - Vector with all x-coords sorted
  - Vector with all y-coords sorted for each node of segtree[x] to lowerbound/upperbound y indices
  - Within each node of segtree[x], store `segtree[][y]` with compressed size 4*log(Sumx_r - Sumx_l)
Query -
  - Search equivalent indices for x-coords in vec
  - Get each node from segtree query
  - Search equivalent indices for y-coords in each vvec[v_x]
  - Get each node sumval from segtree[v_x] query
Variable Names-
  - v -&gt; root vertex
  - l, r -&gt; current left/right segment of coords
  - L, R -&gt; required left/right segment
  - Lyc, Ryc -&gt; c indicates coordinate and not index
Current Progress -
  - Correct Answer and correct Memory Limit
  - Time Limit Exceeded in Building Segtree
      - Building Time: ~ 4min 45 seconds
      - Query Time(for 30000 queries): ~ 5min (9 min 45s in total)
Optimization -
  - Get rid of binary search for both x &amp; y and instead check coord value
  - Remove coord compression but keep construct_order_y
  - Make D&amp;C of segment tree run on array with unique elements (order_x, order_y) instead
  - Fractional Cascading:
      - Store relation(starts) between unique array (order_x) and points
      - So, construct_order_y does not require to binary search index (remove extra logN factor)
</code></pre><p>The Segment Tree is built on the unique x-coordiniates (<code>order_x</code>) array and 2nd dimension in unique y-coordinates (<code>order_y</code>).
It assumes that points do not repeat!</p><p>CTags-like Overview of global variables,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff79c6>const</span> ll SZX <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>30001</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> ll INF <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1.5e9</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Segment Tree : 4*SZX and 4*SZY (still only NlogN memory since dynamic length arrays!)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>ll<span style=color:#ff79c6>&gt;</span> segtree[<span style=color:#bd93f9>4</span><span style=color:#ff79c6>*</span>SZX];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Unique x-coordinates of points
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>ll<span style=color:#ff79c6>&gt;</span> order_x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Unique Y-coordinates of (vx)th segment tree (4*SZX and SZY)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>ll<span style=color:#ff79c6>&gt;</span> order_y[<span style=color:#bd93f9>4</span><span style=color:#ff79c6>*</span>SZX];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// List of all points in sorted x-coordinate order
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>vector<span style=color:#ff79c6>&lt;</span>pair<span style=color:#ff79c6>&lt;</span>ll, ll<span style=color:#ff79c6>&gt;&gt;</span> points;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Fractional-Cascading like map of unique x indices of order_x to non-unique coordinates&#39; indices in points
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>ll starts[SZX];
</span></span></code></pre></div><p>Overview of Functions,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#6272a4>// Query the (vx)th segment tree
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>ll <span style=color:#50fa7b>queryy</span>(ll vx, ll vy, ll ly, ll ry, ll Lyc, ll Ryc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Build (vx)th segment tree on the basis of y-coords (USES queryy for 2*vx, 2*vx+1 segment tree values)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>buildy</span>(ll vx, ll lx, ll rx, ll vy, ll ly, ll ry);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Construct the base array for the (vx)th segment tree (Called within buildx)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>size_t <span style=color:#50fa7b>construct_order_y</span>(ll vx, ll lx, ll rx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Builds the segment tree and proceeds to call construct_order_y and buildy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>buildx</span>(ll vx, ll lx, ll rx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Query the x-coordinate and proceed to call queryy
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>ll <span style=color:#50fa7b>queryx</span>(ll vx, ll lx, ll rx, ll Lxc, ll Rxc, ll Lyc, ll Ryc);
</span></span></code></pre></div><p>The <code>start</code> array is constructed in preprocessing stage before <code>buildx</code>.
<code>construct_order_y</code> uses <code>start</code> array for copying y-coords of original array (so no logN factor from lower_bound).</p><p>Building: <code>buildx</code> -> <code>construct_order_y</code> -> <code>buildy</code> -> (either fill value 1 or <code>queryy</code>)</p><p>Query: Format input to lower/upper endpoints -> <code>queryx</code> -> <code>queryy</code>
At both <code>queryx</code> and <code>queryy</code>(similar but with <code>lxy rxy</code>),
<code>ll lxc = order_x[lx], rxc = order_x[rx];</code>
line is used. The <code>lxc rxc</code> (coordinates of query points) are used for all comparisons except for calculation of midpoint where <code>lx rx</code> (positions) are used.</p><hr><p>3. Closest Pair of Points</p><p>K-D Tree Implementation. See <a href=https://rosettacode.org/wiki/K-d_tree target=_blank rel=noopener>Rosetta Code</a> or Stanford ACM&rsquo;s Notebook.
For intuition on K-D Trees see <a href="https://www.youtube.com/watch?v=cUssdK0Tku4&amp;list=PL8FaHk7qbOD5I3wsXKTC70LwFX6KiA3Yy&amp;index=6" target=_blank rel=noopener>Josh Hug&rsquo;s lectures</a>
General Parameters that can be tuned,</p><ul><li>Distance Metric<ul><li>Euclidean Metric</li><li>Chessboard Metric (Used for this problem)</li><li>Manhattan Metric</li></ul></li><li>Splitting Criteria (X or Y based)<ul><li>Parity of Depth/Height of current node</li><li>Larger of Width or Height of bounding box of current node</li></ul></li></ul><h2 id=week-6---point-location-and-trapezoid-maps>Week 6 - Point Location and Trapezoid Maps</h2><p>Lec 1 - &ldquo;Where the hell am I?&rdquo;</p><ul><li>Planar Subdivision: A set of polygons that form a large polygon.(Like a map of states of a country)</li><li>Partition into vertical lines or slabs at every vertex (like Shamos Hoey)</li><li>Naive Implementation<ul><li>Query: Traverse two binary search trees - find vertical lines (bound on x), find region (bound on y);</li><li>Space Complexity can be n^2 if two full BST</li></ul></li></ul><p>Lec 2 - Decreasing Space Complexity</p><ul><li>Refinement: The Partition of Planar Subdivision S into Slabs induced by vertices. These Partitions would be trapezoids (or degenerate ones).</li><li>Trapezoidal Map: Splits the trapezoids of a refinement. Very useful technique for space partitioning or mapping regions in general.</li><li>Unlike the previous partition by vertical lines, this partition only has lines that end at another edge or outer rectangle.</li><li>Side: Segment of max length contained in boundary of face of trapezoid</li><li>Trapezoidal partition with $n$ segments have, $T(S) \leq 2n + 2*2n + 4$(segment endpoints, vertical lines, boundary rectangle) vertices and trapezois $\leq 3n + 1$</li><li>Constructing Trapezoid - Find each up, down left, right endpoints for each trapezoid. Time: 3N + 1 = O(N)</li></ul><p>Below is an image of a trapezoidal map of &rsquo;line segments&rsquo; from this <a href=https://github.com/marinimau/GAS-Trapezoidal-maps-final-prject target=_blank rel=noopener>GAS</a>, the same can be done for polygons as well.</p><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/trapezoidal_map_line_segments.png><img loading=lazy src=/plots/compgeom/trapezoidal_map_line_segments.png width=auto height=auto alt="Trapezoidal Map of Line Segments"></a></p><p>Lec 3 - Randomized-Incremental Algorithm:</p><ul><li>O(NlogN) expected preprocess time</li><li>O(logN) query time (not worst case optimal but randomized)</li><li>Expected Query Time by Backward Analysis (See Lec04 of series)</li></ul><p>Lec 4 - Data Structure Trapezoid Cartesian DAG</p><ul><li>Trapezoidal Map Data Structure For 2D: Cartesian D.A.G.</li><li>Make sure to split Trapezoid on map (so it isn&rsquo;t n^2 time)</li><li>Unlike Tree, Cartesian DAG will just have pointer to that trapezoid</li></ul><p>Lec 5 - Query Time for Trapezoid Cartesian DAG</p><ul><li>LogN Query time (Amortized)</li><li>Backward Analysis (summation 1/i)</li><li>Size: O(N + 13N) = O(N) (13N comes from $\sum(3i + 1)*(4/i)$)</li><li>Construction: NlogN</li></ul><h2 id=week-7---voronoi-diagrams--post-office-problem>Week 7 - Voronoi Diagrams & Post Office Problem</h2><p>Lec 1 - Post Office Problem</p><ul><li>Post Office Problem: Which is the closest Post Office to place P?</li><li>Answer: Voronoi Diagram with Euclidean Distance Metric. (Map of region closest to that point)</li></ul><p>Lec 2 - Definitions in Voronoi Diagrams</p><ul><li>Voronoi Cell:
$$ V(p) = { x \in R^2: d(x, p) &lt; d(x, q) \forall q \in P\ - {p}} $$</li><li>For Voronoi Cell, Think of definition of Ball in Topology but using relative distances instead of a constant epsilon</li><li>Voronoi Edge:
$$ V(p) = { x \in R^2: d(x, p) == d(x, q) \forall q \in P\ - {p}} $$</li></ul><p>Lec 3 - Overall Shape of Voronoi Diagrams</p><ul><li>Lemma: Vor( P ) consists of atmost (2n - 5) vertices and (3n - 6) edges</li><li>Proof of Lemma from Euler&rsquo;s Polyhedra Formula (Dual is Delaunay Triangulation and Maximal Planar Graph => 3n - 6)</li><li>For infinite voronoi diagrams, set dummy vertex at infinity</li><li>NOTE: Voronoi Vertices != Voronoi Cells (or Faces or Sites)</li><li>Voronoi Vertex: Circle at vertex &lsquo;x&rsquo; has atleast 3 points on it&rsquo;s largest (circumcircle which does not contain a site/face)
$$|C_p(x) \cap P| \geq 3$$</li><li>Voronoi Edge: For edge P to P&rsquo;, there is a vertex &lsquo;x&rsquo; which has P and P&rsquo; on it&rsquo;s largest (circumcircle which does not contain a site/face)
$$\exists x \in E(P, P&rsquo;) st.,\ \ |C_p(x) \cap P| = {P, P&rsquo;}$$</li></ul><p>Lec 4 - Computing Voronoi Diagram</p><ul><li>BF: Line Segment Intersection, Half Plane Intersections > $O(N^2)$ time</li><li>Naive Line Sweep: Event Points are not known before swept</li><li>Fortune&rsquo;s Algorithm or Optimized Line Sweep:<ul><li>Parabolas at the visited vertices form the equidistant line</li><li>Directrix is the Line Sweep at point P, and focus is the visited vertices</li><li>Beachline($\beta$): The lowerbound of each of the parabolas (from the visited vertices so far) merged together.</li><li>The intersection points of the parabolas as the line is swept form the edges of the voronoi diagram.</li><li>See <a href=http://www.raymondhill.net/voronoi/rhill-voronoi.html target=_blank rel=noopener>this</a> for demo. Also, <a href=https://jacquesheunis.com/post/fortunes-algorithm/ target=_blank rel=noopener>this post</a> for explaination.</li></ul></li><li>Beachline Event Points<ul><li>Site(Face) Event: New Sitepoint is found => New Arc is created</li><li>Circle Event: Sweep Line reaches lowest point of circle containing 3 Site Points => Arc of the inner site point is deleted. Voronoi Points are the centre of the circle formed.</li></ul></li></ul><p>Lec 5 - Fortune&rsquo;s Line Sweep Algorithm</p><ul><li>See <a href=https://pvigier.github.io/2018/11/18/fortune-algorithm-details.html target=_blank rel=noopener>PVigier&rsquo;s Blog</a> for implementation resources.</li><li>Also see this <a href=https://jacquesheunis.com/post/fortunes-algorithm/ target=_blank rel=noopener>post by Jacques</a></li><li>Key Functions<ul><li>Find New Circle Event Points (Site Event Points are already known)</li><li>Handle Circle Event (once processed; calls findNewCircleEvent)</li><li>Handle Site Event (once processed; calls findNewCircleEvent)</li></ul></li></ul><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/fortunes.gif><img loading=lazy src=/plots/compgeom/fortunes.gif width=auto height=auto alt="Fortune&amp;rsquo;s Algorithm Wiki"></a></p><h2 id=week-8---delaunay-triangulations>Week 8 - Delaunay Triangulations</h2><p>Lec 1 - Height Interpolation</p><ul><li>Triangulation: Planar subdivision with all inner faces triangles and outer face is Convex Hull</li><li>Since Maximal Planar Graph => (3n - 6) edges. But outer face is CH and needs triangulation (3 - h) edges => 3n - 3 + h edges in total</li></ul><p>Lec 2 - Angle-Optimal Triangulation</p><ul><li>Height Interpolation Optimization by choosing a better triangulation</li><li>Angle-Optimal Triangulation to avoid skinny triangles (this causes disparity in length Vs width - based height interpolations)</li><li>Angle vector $A(T)$ of Triangulation $T$ is the angles of all triangles in sorted order</li><li>A Triangulation is more optimum if Angle vector is <strong>lexicographically</strong> better than the other. i.e., $A(T_{optimal}) > A(T)$</li><li>The best triangulations are called Angle-Optimal.</li></ul><p>Lec 3 - Edge-Flips & Legal Triangulations</p><ul><li>Edge e is illegal in Triangulation T if triangulation obtained by flipping edge e, T&rsquo; has $A(T&rsquo;) > A(T)$</li><li>Use Extended Thales Thm (Thales++), i.e., check angles by taking circumcircle around edge e</li><li>Angle-Optimal is always legal.</li><li>A triangle is <strong>legal</strong> iff it has no illegal edge</li></ul><p>Lec 4 - Voronoi Diagram & Delaunay Triangulation</p><ul><li>Delaunay Triangulation: Straight Line Drawing of the Dual Graph of Voronoi Diagram</li><li>Proof<ul><li>Take circumcircle on any point in edge between sites p-q in Vor(P)</li><li>Consider another edge u-v and show crosses lead to contradiction</li></ul></li><li>Alt Definition: Delauanay Triangulation iff $\forall \Delta \in T : int(C(\Delta) \cap P) = \phi$</li><li>AKA: Empty Circumcircle property of D.T.</li></ul><p>Lec 5 - Correctness and Computation</p><ul><li>A triangulation is legal iff it is Delaunay</li><li>Proof<ul><li>Back Relation: By Empty Circumcircle Property and Thales++, D.T. is legal</li><li>Forward Relation:<ul><li>By Contradiction, Take a triangle p-q-r and circumcircle. where T is legal</li><li>Take point s in circumcircle. Now, we need to maximize angle of chord at s. (p-s-q)</li><li>Take neighbouring triangle p-q-t, t lies outside circumcircle.</li><li>Get contradiction: angle q-s-t > angle p-s-q (but this is maximal)</li></ul></li></ul></li><li>If pointset P is general position(i.e. No 4 points lie on an empty circle) then D.T. is unique and angle-optimal.</li><li>If pointset P is not general position, then all D.T. have same minimum angle but may not be angle-optimal.</li><li>D.T. can be constructed in $O(NlogN)$</li><li>Angle-Optimal Triangulation in non-general position P, can be constructed in $O(N^2)$ time. Holes (4+ points on empty circle) can be filled by trying out each flip.</li></ul><p>Below is an image also showing weighted voronoi diagrams and their corresponding delaunay triangulations,
<a target=_blank rel="noopener noreferrer" href=/plots/compgeom/weighted_dt.png><img loading=lazy src=/plots/compgeom/weighted_dt.png width=auto height=auto alt="Weighted and non-Weighted VD and DT"></a></p><h2 id=week-9---convex-hull-in-3d>Week 9 - Convex Hull in 3D</h2><p>Lec 1 - Complexity and Visibility of CH</p><ul><li>(Upper Bound Theorem) General Time Complexity of Convex Hull in d dimensions: $O(N^{\lfloor d/2 \rfloor})$</li><li>In 3D, Surface of the Polyhedra forms a Planar Dual Graph => atmost (3n-6) edges and hence linear complexity. Similar for higher dimensions.</li><li>Construction by Random-Incremental Algorithm</li><li>Visibility:<ul><li>If we project rays from point P to Convex Polytope.</li><li>The project rays that are 3D Tangent to the polytope form a ring/shadow, the point that form this is called Horizon.(Last visible edges)</li><li>Region facing towards P bounded by Horizon is the Visible region.</li></ul></li><li>Define Conflict Graph and create bipartite relation of points with facets. And mark out which facets are visible.</li></ul><p>Lec 2 - Randomized Incremental Algorithm</p><ul><li>Pseudocode/Approach of adding vertex to CH3</li><li>TC: $O(N^2)$ (Randomized from $O(N^3)$; not worst case optimal)</li></ul><p>Lec 3- Analysis</p><ul><li>Expected No. of Facets Created by CH are bounded to atmost (6n - 20)</li><li>Degree bounded by 6 for the vertices other than initial 4-point CH3, so 6*(n-4) + 4</li><li>See this <a href=https://codeforces.com/blog/entry/81768 target=_blank rel=noopener>Tutorial on 3D CH</a> for simple implementation as well as some optimized version.</li><li>Can be further optimized with Configuration Spaces</li><li>Higher Degree CH are worst case optimal accordingly with Upper Bound Thm.</li></ul><p>Lec 4- Convex Hull & Half-Plane Intersections</p><ul><li>Assume a mapping/relation from spaces P1 and P2, where (&lsquo;primal is the dual of the dual!&rsquo;)<ul><li>Line in P1 -> point in P2 (P1 is Dual of P2)</li><li>Line in P2 -> line in P1 (P2 is Dual of P1)</li></ul></li><li>Convex Hull of a point set in P1 => Set of Lines in P2<ul><li>Traversing the lines corresponding to Lower Hull of P1 alongside intersections, give the Upper Envelope. Similarly for Upper CH.</li><li>Incidence Preserving: Every point in P1 gives Line in P2. So CH region gives area bounded by upper and lower envelope.</li><li>Order Preserving: Maintains an ordering through the mapping.</li></ul></li><li>Scaling to 3D: CH3 of points gives 3D Wrapping/Envelope of 3D Lines</li></ul><p>Lec 5- Voronoi Diagrams Revisited</p><ul><li>Distance to Unit Parabola (From Projection of point q to tangent at p&rsquo;) = intercepts $(pq)^2$</li><li>Take: A (set of planes/halfplanes) have an Upper Envelope (or Supremum or Least Upper Bound 3D Parabola). The planes are thus 3D Tangents to the 3D Parabola or Envelope.</li><li>When this is projected to the plane,<ul><li>Voronoi Centres/Faces/Sites = (Intersection points of Planes and 3D Parabola)</li><li>Voronoi Edges = (Line Segments that for the Intersection of Planes)</li><li>Voronoi Vertices = (Intersection of 3 or more Planes)</li></ul></li><li>Take: 3D Convex Hull of (Intersection of Planes and 3D Parabola). The 3D Parabola is now the Lower Envelope (or Infimum or Greatest Lower Bound) of the (3D Convex Hull).</li><li>When this projected to the plane,<ul><li>Delaunay Vertices = (Intersection of Planes and 3D Parabola) or (Points of 3D Convex Hull)</li><li>Delaunay Edges = (Edges of 3D Convex Hull)</li></ul></li><li>See <a href="https://www.youtube.com/watch?v=H0IVBBDJ8Kk&amp;list=PLubYOWSl9mIubi50UoQt3Sl_CV9NCjUUm&amp;index=5" target=_blank rel=noopener>Video for Demo</a></li></ul><p>Below image is from <a href=https://pages.mtu.edu/~shene/NSF-2/DM2-BETA/index.html target=_blank rel=noopener>DesignMentor</a>, showing delaunay triangulation as a projection of a 3D Convex Hull</p><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/ch3d_as_dt.png><img loading=lazy src=/plots/compgeom/ch3d_as_dt.png width=auto height=auto alt="Delaunay Triangulations as Projection of 3D Convex Hull"></a></p><h2 id=week-10---motion-planning>Week 10 - Motion Planning</h2><p>Lec 1 - Point Shaped Robots</p><ul><li>Trapezoidal Map for Path with Obstacles. Finding Path: O(NlogN) Construction and O(N) query</li></ul><p>Lec 2 - Configuration Space</p><ul><li>Degrees of Freedom: 2D(2 translation x, y + 1 rotation \theta) = 3, 3D(3 translation x,y,z + 2 rotation $\theta, \phi$) = 5</li><li>Configuration Polygon: Polygon s.t. foreach point in ConfPol, Robot at point (x, y) (R(x, y)) intersects with obstacle polygon(Pi). (If point robot, then this is just the obstacle polygons.)</li></ul><p>$$ CP<em>i = {(x, y): R(x, y) \cap P</em>{i}} $$</p><p>Lec 3 - Characterizing Configuration Spaces</p><ul><li>Minkowski&rsquo;s Sum (For Polygon!): $S_1+S_2={p + q : \forall p \in P, q \in Q}$ where p, q are point vectors</li><li>Geometric Representation: Replace Copy of S1 in every point of S2 to form the new shape. (or Vice versa; commutative)</li><li>Inversion in Polygon Algebra: Rotate polygon by 180 around origin. $S2 =-S1={-p : \forall p \in P}$</li><li>Configuration Polygon: $CP = P + (- R(0, 0))$ (where &lsquo;+&rsquo; is minkowski sum)</li></ul><p><a target=_blank rel="noopener noreferrer" href=/plots/compgeom/minkowski_sum_of_polygons.png><img loading=lazy src=/plots/compgeom/minkowski_sum_of_polygons.png width=auto height=auto alt="Configuration Polygon"></a></p><p>Lec 4 - Complexity and Computation</p><ul><li>Atmost n+m edges in minkowski sum(S) of P (n edges) and Q (m edges)</li><li>We can define a map of each edge of S to a pair (i, j) of the edges in P, Q.</li><li>Quadratic Algorithm: Convex Hull of points where at each corner of P, Try every rotation of Q</li><li>Linear Algorithm: (Two-Pointers-like) Choose Bottom-Right most point for both. And move p_ptr or q_ptr based on which has a smaller angle.</li></ul><p>Lec 5 - Pseudodisks</p><ul><li>Def: Pair of Planar Objects (P1, P2) form a pseudodisk if (bound-> boundary, int->interior),<ul><li>$bound(O1) \cap int(O2)$ is connected</li><li>$bound(O2) \cap int(O1)$ is connected</li></ul></li><li>Consider 2 convex polygons with disjoint interiors.<ul><li>Let d1 -> direcion where P1 more extreme, similarly d2.</li><li>Then P1 is more extreme in [d1, d2] or [d2, d1]. Or in a circle, one boundary part has P1 more extreme and other with P2.</li></ul></li><li>For P1, P2, take CP1 = P1 + R, CP2 = P2 + R. Then proof by contradiction. So (CP1, CP2) have to be pseudodisks.</li></ul><p>Lec 6 - Union Complexity</p><ul><li>For Convex Polygons P, Q, R,.., the total union has atmost 2*(n+m+l+..) vertices. (since every (two or less) crossings can be mapped to a vertex)</li><li>For constant complexity convex robot R, translating among S disjoint objects with N edges. We can preprocess in $O(N (logN)^2)$ and compute collision-free path in O(N)</li><li>Approach<ul><li>Triangulate Polygons if Not-Convex to make it convex (NlogN)</li><li>Compute ConfPol for each Obstacle Polygon (N)</li><li>Compute Union of Obstacles by sweep line (N $(logN)^2$)</li><li>Mark out Trapezoidal Maps etc.</li><li>Query: Find path in complement of unionConfPol with help of Trapezoidal Map</li></ul></li></ul></article></div><section class=article-navigation><p align=left>Previous: <a class=link href=/posts/numan/><span class=li></span>Numerical Analysis</a></p><p align=right>Next: <a class=link href=/posts/discrete-vs-continuous/><span class=li></span>Discrete Vs Continuous</a class="link"></p></section><script src=https://giscus.app/client.js data-repo=cheese-cracker/cheese-cracker.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxMzkzMjU3NTU=" data-category=Announcements data-category-id=DIC_kwDOCE3xO84COSY5 data-mapping=title data-reactions-enabled=1 data-emit-metadata=0 data-theme=dark data-lang=en crossorigin=anonymous async></script></section><script charset=utf-8>window.addEventListener("DOMContentLoaded",()=>{const e=new IntersectionObserver(e=>{e.forEach(e=>{const t=e.target.getAttribute("id");e.intersectionRatio>0?document.querySelector(`nav li a[href="#${t}"]`).parentElement.classList.add("active"):document.querySelector(`nav li a[href="#${t}"]`).parentElement.classList.remove("active")})});document.querySelectorAll("h2[id]").forEach(t=>{e.observe(t)})})</script><aside class=toc><details open><summary class=toc-title>TOC</summary><nav id=TableOfContents><ul><li><a href=#key-resources>Key Resources</a><ul><li></li></ul></li><li><a href=#overview>Overview</a><ul><li></li></ul></li><li><a href=#week-1>Week 1</a></li><li><a href=#week-2>Week 2</a></li><li><a href=#week-3>Week 3</a></li><li><a href=#week-4>Week 4</a></li><li><a href=#week-5>Week 5</a></li><li><a href=#week-6---point-location-and-trapezoid-maps>Week 6 - Point Location and Trapezoid Maps</a></li><li><a href=#week-7---voronoi-diagrams--post-office-problem>Week 7 - Voronoi Diagrams & Post Office Problem</a></li><li><a href=#week-8---delaunay-triangulations>Week 8 - Delaunay Triangulations</a></li><li><a href=#week-9---convex-hull-in-3d>Week 9 - Convex Hull in 3D</a></li><li><a href=#week-10---motion-planning>Week 10 - Motion Planning</a></li></ul></nav></details></aside><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>2024 cheese-cracker</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span>Subscribe to my <a href=/index.xml target=_blank rel=noopener>RSS Feeds</a>
<span>| </span>Follow me on <a href=https://github.com/cheese-cracker target=_blank rel=noopener>GitHub</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a> modified!</p></div><div class=footer-wrap>Hits/Visits since Jan 2020: 1100+</div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"})'>^ TOP ^</a></div></section><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script><script type=text/x-mathjax-config>MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script></div></body></html>